# [Silver V] 거스름돈 - 14916 

[문제 링크](https://www.acmicpc.net/problem/14916) 

### 성능 요약

메모리: 31256 KB, 시간: 44 ms

### 분류

수학, 다이나믹 프로그래밍, 그리디 알고리즘

### 문제 설명

<p>춘향이는 편의점 카운터에서 일한다.</p>

<p>손님이 2원짜리와 5원짜리로만 거스름돈을 달라고 한다. 2원짜리 동전과 5원짜리 동전은 무한정 많이 가지고 있다. 동전의 개수가 최소가 되도록 거슬러 주어야 한다. 거스름돈이 n인 경우, 최소 동전의 개수가 몇 개인지 알려주는 프로그램을 작성하시오.</p>

<p>예를 들어, 거스름돈이 15원이면 5원짜리 3개를, 거스름돈이 14원이면 5원짜리 2개와 2원짜리 2개로 총 4개를, 거스름돈이 13원이면 5원짜리 1개와 2원짜리 4개로 총 5개를 주어야 동전의 개수가 최소가 된다.</p>

### 입력 

 <p>첫째 줄에 거스름돈 액수 n(1 ≤ n ≤ 100,000)이 주어진다.</p>

### 출력 

 <p>거스름돈 동전의 최소 개수를 출력한다. 만약 거슬러 줄 수 없으면 -1을 출력한다.</p>
 
 
 <hr>
 
 
 ## 👑 나의 풀이: <br>
 - 처음 풀이: <br>
 <code>
 import sys
input = sys.stdin.readline
#거스름돈 입력받기
n = int(input())
count = 0
#거슬러 줄 수 없는 경우에 대한 처리
if(n==1 or n==3):
    print(-1)
#5를 뺀 값이 2로 나누어떨어질 때 까지만 5를 빼는 것을 반복
while((n-5)%2==0):
    n-=5
    count+=1
#2원의 수 구하기
count+=(n//2)
print(count)
 </code>
→ 처음 문제를 딱 보았을 때, 5원이 큰 수 이므로 먼저 처리해야겠다는 생각이 들었다. 하지만 무작정 5로 나눈 것의 몫을 구하기에는, ‘13’과 같은 예외를 처리하기 어려웠다.
→ 따라서, 일단 거슬러 줄 수 없는 1과 3에 대한 처리를 해주었다.
→ 그리고 5를 뺀 것의 값이 2로 나누어 떨어지는 경우에는 5를 빼주고, count 값을 1을 늘려주었다.
→ 그리고 n으로 2를 나눈 것의 몫을 구해서 최종 값을 구해주었다.
→ 오류가 남 <br><br>
 
 <br>
 - 최종 풀이: <br>
<code>
# 거스름돈 액수 n
n = int(input())    
# 반복해서 나오는 식을 간단하게 변수로 선언해두기
tmp = n % 5 
# 거스름돈이 1이나 3이면 거슬러줄 수 없으므로 -1 출력 
if n == 1 or n == 3:    
    print(-1)
# n이 5로 나누었을 때의 나머지가 짝수이면(2로 나눌 수 있으면) 
elif tmp % 2 == 0: 
    print((n // 5) + (tmp // 2))  # 5로 나눴을 때의 몫 + 그 나머지를 2로 나눴을 때의 몫.
# n이 5로 나누었을 때의 나머지가 홀수이면(2로 나눌 수 없음) 
else:   
    print((n // 5) - 1 + (tmp + 5) // 2)  # 5로 나눴을 때의 몫에서 1을 빼준 값 + 그 나머지에 5를 더해준 후 2로 나눴을 때의 몫.
</code>
→ 1과 3에 대한 처리를 먼저 해주었다.
→ 5로 나누었을 때의 나머지가 2로 나누어 떨어지는 경우, 5로 나눈 몫과 5로 나눈 것의 나머지를 2로 나눈 것의 몫을 더해서 구해주었다.
→ 2로 나누어 떨어지지 않는 경우에는, 5로 나눈 것의 나머지에 다시 5를 더해주고, 그것을 2로 나눈 것의 몫과 5로 나눈것의 몫에 1을 더해준 값을 반환해주었다.
