# [level 1] 모의고사 - 42840 

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42840) 

### 성능 요약

메모리: 10.4 MB, 시간: 6.01 ms

### 구분

코딩테스트 연습 > 완전탐색

### 채점결과

Empty

### 문제 설명

<p>수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.</p>

<p>1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...<br>
2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...<br>
3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...</p>

<p>1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.</p>

<h5>제한 조건</h5>

<ul>
<li>시험은 최대 10,000 문제로 구성되어있습니다.</li>
<li>문제의 정답은 1, 2, 3, 4, 5중 하나입니다.</li>
<li>가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.</li>
</ul>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>answers</th>
<th>return</th>
</tr>
</thead>
        <tbody><tr>
<td>[1,2,3,4,5]</td>
<td>[1]</td>
</tr>
<tr>
<td>[1,3,2,4,2]</td>
<td>[1,2,3]</td>
</tr>
</tbody>
      </table>
<h5>입출력 예 설명</h5>

<p>입출력 예 #1</p>

<ul>
<li>수포자 1은 모든 문제를 맞혔습니다.</li>
<li>수포자 2는 모든 문제를 틀렸습니다.</li>
<li>수포자 3은 모든 문제를 틀렸습니다.</li>
</ul>

<p>따라서 가장 문제를 많이 맞힌 사람은 수포자 1입니다.</p>

<p>입출력 예 #2</p>

<ul>
<li>모든 사람이 2문제씩을 맞췄습니다.</li>
</ul>


> 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges  <br><br>


<hr>

## ❤️ 문제 핵심: <br>
-> 각 학생과 문제 정답의 정답 여부를 비교하는 방법, 거기서 가장 많이 맞힌 학생의 번호를 뽑아내는 것이 관건인 문제인 것 같다. 리스트가 같은 문제로서, 리스트의 인덱스나 각 학생의 정답 수를 저장하기 위해 딕셔너리를 이용할 수 있다는 것<br><br>

## 😀 나의 풀이: <br>
![image](https://github.com/An-jisu/Algorithm/assets/70849122/86c95c4d-98eb-48e9-aa7d-9026df90624e) <br>
-> 학생들의 정답 패턴들을 모두 문자열로 저장해두었다. 그리고 정답 배열의 값들을 하나씩 접근하면서 (두 인덱스가 같음을 이용!!!) 각 학생의 정답을 모두 비교하면서 같으면, 그에 해당하는 answer값을 증가시킨다. answer 배열은 각 학생의 정답 횟수를 저장하고 있다.(0번인덱스: 1번학생, 1번인덱스: 2번학생, 2번인덱스: 3번학생) 마지막에 가장 많이 맞힌 학생을 반환할 때, max값이 여러개인경우(count함수 이용) answer에 있는 값 하나씩 비교하면서, max값이랑 같으면 바로 list에 넣어서 바로 반환시켜주었다. 그리고 1개인 경우에는, 그것의 인덱스+1의 값을 반환시켜주었다. 또 !!! 중요한 것은 학생들의 정답 패턴이 반복되는 것을 나머지 연산자를 이용했다는 것!!! <br><br>

## ⭕ 다른 사람의 풀이: <br>
![image](https://github.com/An-jisu/Algorithm/assets/70849122/f8032389-2af3-4d0b-8b94-c6385f22c413) <br>
-> 나와 같은 풀이 방법이지만, enumerate를 이용했다는 것!! 그리고, 마지막에 가장 맞힌 횟수를 굳이 조건을 나누어주지 않고, max값과 같으면 list에 넣어주게 했어도 될듯하다!! 어쩌피 순서대로 담길 것이므로 자동 오름차순! <br><br>

## ✔️ What I learned: <br>
-> 일정하게 증가하는 것에 해당하는 값을 저장하는 문제는 이렇게 리스트의 인덱스를 그 학생번호라 생각하고 리스트를 이용할 수 있다는 것! <br>
-> 반복되는 패턴에서 끝에서 앞으로 돌아가는 것을 나머지 연산를 이용하여 풀이할 수 있다는 것!! <br>
-> !!!중요!!!!!🎈만약, 리스트나 문자열에서 값과 인덱스를 모두 필요로하는데, 무엇으로 range할지 그냥 in으로 값에 접근할 지 애매할 땐, enumerate 이용하기!!!!!!
