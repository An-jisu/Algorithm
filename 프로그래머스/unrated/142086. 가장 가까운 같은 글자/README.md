# [unrated] 가장 가까운 같은 글자 - 142086 

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/142086) 

### 성능 요약

메모리: 11 MB, 시간: 22.13 ms

### 구분

코딩테스트 연습 > 연습문제

### 채점결과

Empty

### 문제 설명

<p>문자열 <code>s</code>가&nbsp;주어졌을 때, <code>s</code>의 각 위치마다 자신보다 앞에 나왔으면서, 자신과 가장 가까운 곳에 있는 같은 글자가 어디 있는지 알고 싶습니다.<br>
예를 들어, <code>s</code>="banana"라고 할 때,&nbsp; 각 글자들을 왼쪽부터 오른쪽으로 읽어 나가면서&nbsp;다음과 같이 진행할 수 있습니다.</p>

<ul>
<li>b는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.</li>
<li>a는 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.</li>
<li>n은 처음 나왔기 때문에 자신의 앞에 같은 글자가 없습니다. 이는 -1로 표현합니다.</li>
<li>a는 자신보다 두 칸 앞에 a가 있습니다. 이는 2로 표현합니다.</li>
<li>n도&nbsp;자신보다 두 칸 앞에 n이 있습니다. 이는 2로 표현합니다.</li>
<li>a는 자신보다 두 칸, 네 칸 앞에 a가 있습니다. 이 중 가까운 것은 두 칸 앞이고, 이는 2로 표현합니다.</li>
</ul>

<p>따라서 최종 결과물은 [-1, -1, -1, 2, 2, 2]가 됩니다.</p>

<p>문자열 <code>s</code>이 주어질 때, 위와 같이 정의된 연산을 수행하는 함수 solution을 완성해주세요.</p>

<hr>

<h5>제한사항</h5>

<ul>
<li>1 ≤ <code>s</code>의 길이 ≤ 10,000

<ul>
<li><code>s</code>은 영어 소문자로만 이루어져 있습니다.</li>
</ul></li>
</ul>

<hr>

<h5>입출력 예</h5>
<table class="table">
        <thead><tr>
<th>s</th>
<th>result</th>
</tr>
</thead>
        <tbody><tr>
<td>"banana"</td>
<td>[-1, -1, -1, 2, 2, 2]</td>
</tr>
<tr>
<td>"foobar"</td>
<td>[-1, -1, 1, -1, -1, -1]</td>
</tr>
</tbody>
      </table>
<hr>

<h5>입출력 예 설명</h5>

<p>입출력 예 #1<br>
지문과 같습니다.</p>

<p>입출력 예 #2<br>
설명 생략</p>


> 출처: 프로그래머스 코딩 테스트 연습, https://programmers.co.kr/learn/challenges   <br><br>

<hr>

## ❤️ 문제 핵심: <br>
-> 앞으로 돌아가서 가장 가까운 그 문자와의 거리를 구하는 것이 핵심이다. <br><br>

## 😀 처음 풀이: <br>
![image](https://user-images.githubusercontent.com/70849122/236723781-65d91a68-e140-45d0-b7b0-c1c58cefa7a2.png) <br>
-> 주어진 2개의 테스트 케이스에 대해선 돌아가지만, <br>
![image](https://user-images.githubusercontent.com/70849122/236723878-44029de8-2292-4370-8257-c2a6668921b2.png) <br>
-> 위와 같이 오류가 나는 것이다. 이유는 안쪽 반복문에서 끝점을 0이 아닌 -1을 해주어야 한다. (abcda와 같은 반례를 처리하기 위해서) 나는 그 반례도 적용해서 첫번째 인덱스인 0번째까지 접근하게끔 코딩한 것이다. 그런데, 거꾸로 반복문을 돌 때의 끝점도 하나 더 작은 수로 해야하는지에 대한 혼란이 있었다. 반복문을 거꾸로 작성할때의 범위에 대해서도 확실히 알아두자.<br><br>

## 😀 최종 풀이: <br>
![image](https://user-images.githubusercontent.com/70849122/236724099-0158bf46-cd8e-46c1-969a-a5062198a2ee.png) <br>
-> 0만 -1로 바꿔주니까 제대로 실행이 되었다. 앞으로 돌아가서 그 문자와 가장 가까운 같은 문자와의 인덱스 차이를 구하는 알고리즘에 대한 고민이 많았다. <br>
-> 나는 중첩 반복문을 활용하여, 그 수부터 0번째 인덱스까지 거꾸로 살펴보면서, 같은 값이 존재하면 num 인덱스 차이를 저장하게 하였다. 그런데 안쪽 반복문이 끝날 때까지 num의 값이 변화가 없고 0이라면, 같은 문자가 존재하지 않는 것이므로 -1을 append 하였다. <br><br>

## ⭕ 다른 사람의 풀이: <br>
![image](https://user-images.githubusercontent.com/70849122/236724707-f7b80739-f926-4826-85fd-102968ca3d09.png) <br>
-> 위 코드는 딕셔너리를 이용해서, 각 알파벳에 대한 인덱스를 계속 최신의 걸로 업데이트 해 나간다. 그래서 앞에 같은 문제가 존재하는 경우에는, 그 문자와 딕셔너리에 담긴 그 문자의 인덱스의 차이를 구해준다. <br>
-> 어쨌튼 여기서도 인덱스 차이를 이용한다. 그런데, 그 가장 가까운 인덱스를 찾는 것을 최신의 인덱스로 바꿔놓는 방법을 통해서 수행했다. <br><br>


## ✔️ What I learned: <br>
-> for i in range(i-1, -1, -1) : 이렇게 -1로 반복문을 거꾸로 돌 때에는 끝점을 도착 지점보다 하나 더 작은 값을 넣어줘야 함! <br>
